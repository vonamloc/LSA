import{Element,Chart,defaults,Animations}from"chart.js";import{distanceBetweenPoints,callback,isFinite,toFontString,isArray,toRadians,isObject,clipArea,unclipArea,valueOrDefault}from"chart.js/helpers";const clickHooks=["click","dblclick"],moveHooks=["enter","leave"],hooks=clickHooks.concat(moveHooks);function updateListeners(e,a,t){const n=a.annotations||[];a.listened=!1,a.moveListened=!1,hooks.forEach(e=>{"function"==typeof t[e]&&(a.listened=!0,a.listeners[e]=t[e])}),moveHooks.forEach(e=>{"function"==typeof t[e]&&(a.moveListened=!0)}),a.listened&&a.moveListened||n.forEach(t=>{a.listened||clickHooks.forEach(e=>{"function"==typeof t[e]&&(a.listened=!0)}),a.moveListened||moveHooks.forEach(e=>{"function"==typeof t[e]&&(a.listened=!0,a.moveListened=!0)})})}function handleEvent(e,t,a,n){if(t.listened)switch(a.type){case"mousemove":case"mouseout":handleMoveEvents(e,t,a);break;case"click":handleClickEvents(e,t,a,n)}}function handleMoveEvents(t,a,n){if(a.moveListened){let e;"mousemove"===n.type&&(e=getNearestItem(a.elements,n));n=a.hovered;a.hovered=e,dispatchMoveEvents(t,a,n,e)}}function dispatchMoveEvents(e,t,a,n){a&&a!==n&&dispatchEvent(e,t,a.options.leave||t.listeners.leave,a),n&&n!==a&&dispatchEvent(e,t,n.options.enter||t.listeners.enter,n)}function handleClickEvents(e,t,a,n){var o=t.listeners;const i=getNearestItem(t.elements,a);if(i){var r=i.options,a=r.dblclick||o.dblclick;const s=r.click||o.click;i.clickTimeout?(clearTimeout(i.clickTimeout),delete i.clickTimeout,dispatchEvent(e,t,a,i)):a?i.clickTimeout=setTimeout(()=>{delete i.clickTimeout,dispatchEvent(e,t,s,i)},n.dblClickSpeed):dispatchEvent(e,t,s,i)}}function dispatchEvent(e,t,a,n){callback(a,[{chart:e,element:n}])}function getNearestItem(e,n){let o=Number.POSITIVE_INFINITY;return e.filter(e=>e.options.display&&e.inRange(n.x,n.y)).reduce((e,t)=>{var a=t.getCenterPoint(),a=distanceBetweenPoints(n,a);return a<o?(e=[t],o=a):a===o&&e.push(t),e},[]).sort((e,t)=>e._index-t._index).slice(0,1)[0]}const PI$1=Math.PI,HALF_PI=PI$1/2;function scaleValue(e,t,a){return t="number"==typeof t?t:e.parse(t),isFinite(t)?e.getPixelForValue(t):a}function roundedRect(e,t,a,n,o,i){var r,s,l,d;e.beginPath(),i?(s=t+(r=Math.min(i,o/2,n/2)),l=t+n-r,d=a+o-r,e.moveTo(t,i=a+r),s<l&&i<d?(e.arc(s,i,r,-PI$1,-HALF_PI),e.arc(l,i,r,-HALF_PI,0),e.arc(l,d,r,0,HALF_PI),e.arc(s,d,r,HALF_PI,PI$1)):s<l?(e.moveTo(s,a),e.arc(l,i,r,-HALF_PI,HALF_PI),e.arc(s,i,r,HALF_PI,PI$1+HALF_PI)):i<d?(e.arc(s,i,r,-PI$1,0),e.arc(s,d,r,0,PI$1)):e.arc(s,i,r,-PI$1,PI$1),e.closePath(),e.moveTo(t,a)):e.rect(t,a,n,o)}function rotated(e,t,a){var n=Math.cos(a),o=Math.sin(a),a=t.x,t=t.y;return{x:a+n*(e.x-a)-o*(e.y-t),y:t+o*(e.x-a)+n*(e.y-t)}}class BoxAnnotation extends Element{inRange(e,t,a){var{x:n,y:o,width:i,height:a}=this.getProps(["x","y","width","height"],a);return n<=e&&e<=n+i&&o<=t&&t<=o+a}getCenterPoint(e){var{x:t,y:a,width:n,height:e}=this.getProps(["x","y","width","height"],e);return{x:t+n/2,y:a+e/2}}draw(e){var{x:t,y:a,width:n,height:o,options:i}=this;e.save(),e.lineWidth=i.borderWidth,e.strokeStyle=i.borderColor,e.fillStyle=i.backgroundColor,e.setLineDash(i.borderDash),e.lineDashOffset=i.borderDashOffset,roundedRect(e,t,a,n,o,i.cornerRadius),e.fill(),i.borderWidth&&e.stroke(),e.restore()}resolveElementProperties(e,t){var a=e.scales[t.xScaleID],n=e.scales[t.yScaleID];let{top:o,left:i,bottom:r,right:s}=e.chartArea,l,d;return a||n?(a&&(l=scaleValue(a,t.xMin,i),d=scaleValue(a,t.xMax,s),i=Math.min(l,d),s=Math.max(l,d)),n&&(l=scaleValue(n,t.yMin,r),d=scaleValue(n,t.yMax,o),o=Math.min(l,d),r=Math.max(l,d)),{x:i,y:o,x2:s,y2:r,width:s-i,height:r-o}):{options:{}}}}BoxAnnotation.id="boxAnnotation",BoxAnnotation.defaults={display:!0,adjustScaleRange:!0,borderDash:[],borderDashOffset:0,borderWidth:1,cornerRadius:0,xScaleID:"x",xMin:void 0,xMax:void 0,yScaleID:"y",yMin:void 0,yMax:void 0},BoxAnnotation.defaultRoutes={borderColor:"color",backgroundColor:"color"};const PI=Math.PI,clamp=(e,t,a)=>Math.min(a,Math.max(t,e)),pointInLine=(e,t,a)=>({x:e.x+a*(t.x-e.x),y:e.y+a*(t.y-e.y)}),interpolateX=(e,t,a)=>pointInLine(t,a,Math.abs((e-t.y)/(a.y-t.y))).x,interpolateY=(e,t,a)=>pointInLine(t,a,Math.abs((e-t.x)/(a.x-t.x))).y,toPercent=e=>"string"==typeof e&&e.endsWith("%")&&parseFloat(e)/100;function limitPointToArea({x:e,y:t},a,{top:n,right:o,bottom:i,left:r}){return e<r&&(t=a.x<r?NaN:interpolateY(r,{x:e,y:t},a),e=r),o<e&&(t=a.x>o?NaN:interpolateY(o,{x:e,y:t},a),e=o),t<n&&(e=a.y<n?NaN:interpolateX(n,{x:e,y:t},a),t=n),i<t&&(e=a.y>i?NaN:interpolateX(i,{x:e,y:t},a),t=i),{x:e,y:t}}function limitLineToArea(e,t,a){var{x:n,y:o}=limitPointToArea(e,t,a),{x:e,y:a}=limitPointToArea(t,e,a);return{x:n,y:o,x2:e,y2:a,width:Math.abs(e-n),height:Math.abs(a-o)}}class LineAnnotation extends Element{intersects(e,t,a=.001){var n=e=>e*e,{x:o,y:i,x2:r,y2:s}=this,l=r-o,d=s-i,c=n(l)+n(d),c=0===c?-1:((e-o)*l+(t-i)*d)/c;let h,u;return u=c<0?(h=o,i):1<c?(h=r,s):(h=o+c*l,i+c*d),n(e-h)+n(t-u)<a}labelIsVisible(){var e=this.options.label;return e&&e.enabled&&e.content}isOnLabel(e,t){var{labelRect:a}=this;if(!a||!this.labelIsVisible())return!1;var{x:n,y:o}=rotated({x:e,y:t},a,-a.rotation),e=a.width/2,t=a.height/2;return n>=a.x-e&&n<=a.x+e&&o>=a.y-t&&o<=a.y+t}inRange(e,t){var a=this.options.borderWidth||1;return this.intersects(e,t,a)||this.isOnLabel(e,t)}getCenterPoint(){return{x:(this.x2+this.x)/2,y:(this.y2+this.y)/2}}draw(e){var{x:t,y:a,x2:n,y2:o,options:i}=this;e.save(),e.lineWidth=i.borderWidth,e.strokeStyle=i.borderColor,e.setLineDash(i.borderDash),e.lineDashOffset=i.borderDashOffset,e.beginPath(),e.moveTo(t,a),e.lineTo(n,o),e.stroke(),e.restore()}drawLabel(e,t){this.labelIsVisible()&&(e.save(),drawLabel(e,this,t),e.restore())}resolveElementProperties(e,t){const a=e.scales[t.scaleID];let{top:n,left:o,bottom:i,right:r}=e.chartArea;var s,l;return a?(s=scaleValue(a,t.value,NaN),l=scaleValue(a,t.endValue,s),a.isHorizontal()?(o=s,r=l):(n=s,i=l)):(s=e.scales[t.xScaleID],l=e.scales[t.yScaleID],s&&(o=scaleValue(s,t.xMin,o),r=scaleValue(s,t.xMax,r)),l&&(n=scaleValue(l,t.yMin,n),i=scaleValue(l,t.yMax,i))),limitLineToArea({x:o,y:n},{x:r,y:i},e.chartArea)}}function calculateAutoRotation(e){var{x:t,y:a,x2:n,y2:e}=e,t=Math.atan2(e-a,n-t);return t>PI/2?t-PI:t<PI/-2?t+PI:t}function drawLabel(a,e,t){var n=e.options.label;a.font=toFontString(n.font);var{width:o,height:i}=measureLabel(a,n),e=e.labelRect=calculateLabelPosition(e,o,i,t);if(a.translate(e.x,e.y),a.rotate(e.rotation),a.fillStyle=n.backgroundColor,roundedRect(a,-o/2,-i/2,o,i,n.cornerRadius),a.fill(),a.fillStyle=n.color,isArray(n.content)){a.textAlign=n.textAlign;var r=calculateLabelXAlignment(n,o);let t=-i/2+n.yPadding;for(let e=0;e<n.content.length;e++)a.textBaseline="top",a.fillText(n.content[e],r,t),t+=n.font.size+n.yPadding}else n.content instanceof Image?(t=-o/2+n.xPadding,e=-i/2+n.yPadding,a.drawImage(n.content,t,e,o-2*n.xPadding,i-2*n.yPadding)):(a.textAlign="center",a.textBaseline="middle",a.fillText(n.content,0,0))}function calculateLabelXAlignment(e,t){var{textAlign:a,xPadding:e}=e;return"start"===a?-t/2+e:"end"===a?+t/2-e:0}function getImageSize(e,t){return"number"==typeof t?t:"string"==typeof t?toPercent(t)*e:e}LineAnnotation.id="lineAnnotation",LineAnnotation.defaults={display:!0,adjustScaleRange:!0,borderWidth:2,borderDash:[],borderDashOffset:0,label:{backgroundColor:"rgba(0,0,0,0.8)",drawTime:void 0,font:{family:void 0,lineHeight:void 0,size:void 0,style:"bold",weight:void 0},color:"#fff",xPadding:6,yPadding:6,rotation:0,cornerRadius:6,position:"center",xAdjust:0,yAdjust:0,textAlign:"center",enabled:!1,content:null},value:void 0,endValue:void 0,scaleID:void 0,xScaleID:"x",xMin:void 0,xMax:void 0,yScaleID:"y",yMin:void 0,yMax:void 0},LineAnnotation.defaultRoutes={borderColor:"color"};const widthCache=new Map;function measureLabel(t,e){var a=e.content;if(a instanceof Image)return{width:getImageSize(a.width,e.width)+2*e.xPadding,height:getImageSize(a.height,e.height)+2*e.yPadding};var n=isArray(a)?a:[a],o=n.length;let i=0;for(let e=0;e<o;e++){var r=n[e];widthCache.has(r)||widthCache.set(r,t.measureText(r).width),i=Math.max(i,widthCache.get(r))}return i+=2*e.xPadding,{width:i,height:o*e.font.size+(o+1)*e.yPadding}}function calculateLabelPosition(e,t,a,n){var o=e.options.label,{xAdjust:i,yAdjust:r,xPadding:s,yPadding:l,position:d}=o,c={x:e.x,y:e.y},h={x:e.x2,y:e.y2},u="auto"===o.rotation?calculateAutoRotation(e):toRadians(o.rotation),o=rotatedSize(t,a,u),d=calculateT(e,d,o,n),d=pointInLine(c,h,d),s={size:o.w,min:n.left,max:n.right,padding:s},l={size:o.h,min:n.top,max:n.bottom,padding:l};return{x:adjustLabelCoordinate(d.x,s)+i,y:adjustLabelCoordinate(d.y,l)+r,width:t,height:a,rotation:u}}function rotatedSize(e,t,a){var n=Math.cos(a),a=Math.sin(a);return{w:Math.abs(e*n)+Math.abs(t*a),h:Math.abs(e*a)+Math.abs(t*n)}}function calculateT(e,t,a,n){let o=.5;var i=spaceAround(e,n),n=e.options.label;return"start"===t?o=calculateTAdjust({w:e.x2-e.x,h:e.y2-e.y},a,n,i):"end"===t&&(o=1-calculateTAdjust({w:e.x-e.x2,h:e.y-e.y2},a,n,i)),o}function calculateTAdjust(e,t,a,n){var{xPadding:o,yPadding:i}=a,a=e.w*n.dx,e=e.h*n.dy,a=0<a&&(t.w/2+o-n.x)/a,e=0<e&&(t.h/2+i-n.y)/e;return clamp(Math.max(a,e),0,.25)}function spaceAround(e,t){var{x:a,x2:n,y:o,y2:i}=e,r=Math.min(o,i)-t.top,e=Math.min(a,n)-t.left,i=t.bottom-Math.max(o,i),n=t.right-Math.max(a,n);return{x:Math.min(e,n),y:Math.min(r,i),dx:e<n?1:-1,dy:r<i?1:-1}}function adjustLabelCoordinate(e,t){var{size:a,min:n,max:o,padding:i}=t,t=a/2;return o-n<a?(o+n)/2:o<=(e=e-i-t<=n?n+i+t:e)+i+t?o-i-t:e}class EllipseAnnotation extends BoxAnnotation{inRange(e,t){return pointInEllipse({x:e,y:t},this)}draw(e){var{width:t,height:a,options:n}=this,o=this.getCenterPoint();e.save(),e.beginPath(),e.lineWidth=n.borderWidth,e.strokeStyle=n.borderColor,e.fillStyle=n.backgroundColor,e.setLineDash(n.borderDash),e.lineDashOffset=n.borderDashOffset,e.ellipse(o.x,o.y,a/2,t/2,Math.PI/2,0,2*Math.PI),e.fill(),e.stroke(),e.restore()}}function pointInEllipse(e,t){var{width:a,height:n}=t,t=t.getCenterPoint(!0),a=a/2,n=n/2;return!(a<=0||n<=0)&&Math.pow(e.x-t.x,2)/Math.pow(a,2)+Math.pow(e.y-t.y,2)/Math.pow(n,2)<=1}EllipseAnnotation.id="ellipseAnnotation",EllipseAnnotation.defaults={display:!0,adjustScaleRange:!0,borderDash:[],borderDashOffset:0,borderWidth:1,xScaleID:"x",xMin:void 0,xMax:void 0,yScaleID:"y",yMin:void 0,yMax:void 0},EllipseAnnotation.defaultRoutes={borderColor:"color",backgroundColor:"color"};class PointAnnotation extends Element{inRange(e,t){var{width:a,options:n}=this,o=this.getCenterPoint(!0),n=a/2+n.borderWidth;return!(n<=0)&&Math.pow(e-o.x,2)+Math.pow(t-o.y,2)<=Math.pow(n,2)}getCenterPoint(e){var{x:t,y:e}=this.getProps(["x","y"],e);return{x:t,y:e}}draw(e){var{x:t,y:a,width:n,options:o}=this;e.save(),e.lineWidth=o.borderWidth,e.strokeStyle=o.borderColor,e.fillStyle=o.backgroundColor,e.setLineDash(o.borderDash),e.lineDashOffset=o.borderDashOffset,e.beginPath(),e.arc(t,a,n/2,0,2*Math.PI),e.fill(),e.stroke(),e.restore()}resolveElementProperties(e,t){var{chartArea:a,scales:n}=e,e=n[t.xScaleID],n=n[t.yScaleID];let o=a.width/2,i=a.height/2;return e&&(o=scaleValue(e,t.xValue,o)),n&&(i=scaleValue(n,t.yValue,i)),{x:o,y:i,width:2*t.radius,height:2*t.radius}}}PointAnnotation.id="pointAnnotation",PointAnnotation.defaults={display:!0,adjustScaleRange:!0,borderDash:[],borderDashOffset:0,borderWidth:1,radius:10,xScaleID:"x",xValue:void 0,yScaleID:"y",yValue:void 0},PointAnnotation.defaultRoutes={borderColor:"color",backgroundColor:"color"};var version="1.0.2";const chartStates=new Map,annotationTypes={box:BoxAnnotation,line:LineAnnotation,ellipse:EllipseAnnotation,point:PointAnnotation};Object.keys(annotationTypes).forEach(e=>{defaults.describe(`elements.${annotationTypes[e].id}`,{_fallback:"plugins.annotation"})});var annotation={id:"annotation",version:version,afterRegister(){Chart.register(annotationTypes)},afterUnregister(){Chart.unregister(annotationTypes)},beforeInit(e){chartStates.set(e,{annotations:[],elements:[],listeners:{},listened:!1,moveListened:!1})},beforeUpdate(e,t,a){const n=chartStates.get(e),o=n.annotations=[];let i=a.annotations;isObject(i)?Object.keys(i).forEach(e=>{const t=i[e];isObject(t)&&(t.id=e,o.push(t))}):isArray(i)&&o.push(...i)},afterDataLimits(e,t){const a=chartStates.get(e);adjustScaleRange(e,t.scale,a.annotations.filter(e=>e.display&&e.adjustScaleRange))},afterUpdate(e,t,a){var n=chartStates.get(e);updateListeners(e,n,a),updateElements(e,n,a,t.mode)},beforeDatasetsDraw(e){draw(e,"beforeDatasetsDraw")},afterDatasetsDraw(e){draw(e,"afterDatasetsDraw")},beforeDraw(e){draw(e,"beforeDraw")},afterDraw(e){draw(e,"afterDraw")},beforeEvent(e,t,a){handleEvent(e,chartStates.get(e),t.event,a)},destroy(e){chartStates.delete(e)},_getState(e){return chartStates.get(e)},defaults:{drawTime:"afterDatasetsDraw",dblClickSpeed:350,animations:{numbers:{properties:["x","y","x2","y2","width","height"],type:"number"}},label:{drawTime:null}},descriptors:{_indexable:!1,_scriptable:e=>!hooks.includes(e),annotations:{_allKeys:!1,_fallback:(e,t)=>`elements.${annotationTypes[t.type||"line"].id}`}},additionalOptionScopes:[""]};const directUpdater={update:Object.assign};function resolveAnimations(e,t,a){return"reset"===a||"none"===a||"resize"===a?directUpdater:new Animations(e,t)}function updateElements(a,e,t,n){const o=resolveAnimations(a,t.animations,n);var i=e.annotations;const r=resyncElements(e.elements,i);for(let t=0;t<i.length;t++){const l=i[t];let e=r[t];const d=annotationTypes[l.type]||annotationTypes.line;e&&e instanceof d||(e=r[t]=new d);var s=resolveAnnotationOptions(l.setContext(getContext(a,e,l)));const c=e.resolveElementProperties(a,s);c.skip=isNaN(c.x)||isNaN(c.y),c.options=s,o.update(e,c)}}function resolveAnnotationOptions(e){var t=annotationTypes[e.type]||annotationTypes.line;const a={};a.id=e.id,a.type=e.type,a.drawTime=e.drawTime,Object.assign(a,resolveObj(e,t.defaults),resolveObj(e,t.defaultRoutes));for(const n of hooks)a[n]=e[n];return a}function resolveObj(e,t){const a={};for(const i of Object.keys(t)){var n=t[i],o=e[i];a[i]=isObject(n)?resolveObj(o,n):o}return a}function getContext(e,t,a){return t.$context||(t.$context=Object.assign(Object.create(e.getContext()),{element:t,id:a.id,type:"annotation"}))}function resyncElements(e,t){var a=t.length,t=e.length;return t<a?e.splice(t,0,...new Array(a-t)):a<t&&e.splice(a,t-a),e}function draw(e,t){const{ctx:a,chartArea:n}=e,o=chartStates.get(e),i=o.elements.filter(e=>!e.skip&&e.options.display);clipArea(a,n),i.forEach(e=>{e.options.drawTime===t&&e.draw(a)}),unclipArea(a),i.forEach(e=>{"drawLabel"in e&&e.options.label&&(e.options.label.drawTime||e.options.drawTime)===t&&e.drawLabel(a,n)})}function adjustScaleRange(e,t,a){a=getScaleLimits(t,a);let n=!1;isFinite(a.min)&&void 0===t.options.min&&void 0===t.options.suggestedMin&&(n=t.min!==a.min,t.min=a.min),isFinite(a.max)&&void 0===t.options.max&&void 0===t.options.suggestedMax&&(n=t.max!==a.max,t.max=a.max),n&&"function"==typeof t.handleTickRangeOptions&&t.handleTickRangeOptions()}function getScaleLimits(e,t){var a=e.axis,n=e.id,o=a+"ScaleID";let i=valueOrDefault(e.min,Number.NEGATIVE_INFINITY),r=valueOrDefault(e.max,Number.POSITIVE_INFINITY);for(const d of t)if(d.scaleID===n)for(const c of["value","endValue"]){var s=d[c];s&&(s=e.parse(s),i=Math.min(i,s),r=Math.max(r,s))}else if(d[o]===n)for(const h of[a+"Min",a+"Max",a+"Value"]){var l=d[h];l&&(l=e.parse(l),i=Math.min(i,l),r=Math.max(r,l))}return{min:i,max:r}}export default annotation;